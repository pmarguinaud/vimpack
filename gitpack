#!/usr/bin/perl -w

use strict;
use File::Find;
use File::Path;
use File::Basename;
use FileHandle;
use File::stat;
use Data::Dumper;
use Cwd;
use Getopt::Long;

sub bt
{ 
  print @_;
  for (my $i = 0; ; $i++)
    {
      last unless (my @call = caller ($i));
      print " $i ", $call[1], ':', $call[2], "\n";
    }
  die "\n";
}

local $SIG{__WARN__} = \&bt;
local $SIG{__DIE__} = \&bt;

my $cwd = &cwd ();

my %opts;

my @GIT = ('/bin/git');

sub git
{
  use POSIX qw ();
  my ($command, @args) = @_;
  chdir ("$cwd/.gitpack/git");

  my @cmd = (@GIT, $command, @args);
  print "@cmd\n" if ($opts{verbose});

  if (system (@cmd))
    {
      my $c = $?;
      my $signal = $c & 127;
      die unless ($signal == &POSIX::SIGPIPE); # Ignore PIPE signal (generated by "| less")
    }
  chdir ($cwd);
}

my @r = qw (branch push status log show rm add commit mv fetch diff);
my @w = qw (checkout pull merge reset);

if (@ARGV && ($ARGV[0] =~ m/^-/o))
  {
    &GetOptions
    (
      verbose => \$opts{verbose},
    );
  }

my $command = shift;
my @args = @ARGV;

my @view = do { my $fh = 'FileHandle'->new ('<.gmkview'); <$fh> };
chomp for (@view);
@view = map { "src/$_" } @view;
@view = ('.gitpack/tmp', @view);

$command or exec (@GIT);

my $r = grep { $_ eq $command } @r;
my $w = grep { $_ eq $command } @w;

unless ($r || $w)
  {
    die ("Unknown command `$command'\n");
  }


sub scanPack
{
  my @view = @_;

  my %p;

  for my $view (@view)
    {
      chdir ("$cwd/$view");
      &find ({wanted => sub { my $f = $File::Find::name; $p{$f} ||= 'File::Spec'->rel2abs ($f) if (&ok ($f)) }, no_chdir => 1}, grep { -d } <*>);
      chdir ($cwd);
    }

  return \%p;
}

sub ok
{
  my $f = shift;
  return unless (-f $f);
  return if ($f =~ m/\.(?:lst|optrpt|o|mod|ok)$/o);
  return if ($f =~ m,odb/ddl\.\w+/\w+.(?:c|h|ddl_),o);
  return 1;
}

sub doLink
{
  my ($f, $g) = @_;
  print "$f -> $g\n" if ($opts{verbose});
  unlink ($g) if (-f $g);
  my $d = &dirname ($g);
  &mkpath ($d) unless (-d $d);
  link ($f, $g);
}

sub doZeroFile
{
  my $f = shift;
  my $d = &dirname ($f);
  &mkpath ($d) unless (-d $d);
  unlink ($f);
  'FileHandle'->new (">$f");
}

sub doUnlink
{
  my $f = shift;
  print "RM $f\n" if ($opts{verbose});
  unlink ($f);
}

sub slurp
{
  my $f = shift;
  my $fh = 'FileHandle'->new ("<$f");
  local $/ = undef;
  my $data = <$fh>;
  return $data;
}

sub testEqualFiles
{
  # Try to make it fast
  my ($f, $g, $stf, $stg) = @_;

  $stf ||= stat ($f);
  $stg ||= stat ($g);

  # Very same file
  return 1 if (($stf->dev == $stg->dev) && ($stf->ino == $stg->ino));

  # Different size 
  return 0 if ($stf->size != $stg->size);

  # Slow: compare file contents
  return 1 if (&slurp ($f) eq &slurp ($g));

  return 0;
}

sub newer
{
  my ($f, $g, $stf, $stg) = @_;
  return $stf->mtime > $stg->mtime;
}

my $s = '.gitpack/time';
my $sts = stat ($s);

my $v0 = &scanPack ($view[0]); # Scan tmp
my $v1 = &scanPack ($view[1]); # Scan local

my @f = keys (%{ {%$v0, %$v1} });

my (@p, @m, @c); # +, -, changed

for my $f (@f)
  {
    my ($f0, $f1) = ($v0->{$f}, $v1->{$f});

    if ($f1)
      {
        my $stf1 = stat ($f1);
        next if (&newer ($s, $f1, $sts, $stf1));
      }

    if ($f0 && (! $f1))
      {
        push @m, $f;
      }
    elsif ($f1 && (! $f0))
      {
        push @p, $f;
      }
    elsif (! &testEqualFiles ($f0, $f1))
      {
        push @c, $f;
      }
  }

# Add new/modified files

for my $f (@c, @p)
  {
    &doLink ($v1->{$f}, "$cwd/.gitpack/tmp/$f");
    &doLink ($v1->{$f}, "$cwd/.gitpack/git/$f"); 
    &git ('add', '-f', $f);
  }

# Remove deleted files

for my $f (@m)
  {
    &doUnlink ("$cwd/.gitpack/tmp/$f");
    &git ('rm', '-f', $f);
  }

&git ($command, @args);

if ($w)
  {
    my $g = &scanPack ('.gitpack/git');

    MAIN: for my $f (sort keys (%$g))
      {
        my $stf = stat ($g->{$f});
     
        # This file has already been looked at earlier; skip it
        next MAIN if (&newer ($s, $g->{$f}, $sts, $stf));
       
        if (my $stl = stat ("$cwd/$view[0]/$f"))
          {
            unless ($stl->size) 
              {
                # File was marked as removed in tmp directory, but was retrieved by a checkout
                # Remove the zero sized file
                &doUnlink ("$cwd/$view[$_]/$f") for (0 .. 1);
              }
          }

        for my $view (@view[2..$#view])
          {
            my $v = "$cwd/$view/$f";
            next unless (my $stv = stat ($v));
            if (&testEqualFiles ($g->{$f}, $v, $stf, $stv))
              {
                # File exists and is the same as in the git repo, remove local copy
                &doUnlink ("$cwd/$view[$_]/$f") for (0 .. 1);
                next MAIN;
              }
            else
              {
                last;
              }
           }
        &doLink ($g->{$f}, "$cwd/$view[$_]/$f") for (0 .. 1);
      }

    my $v0 = &scanPack ($view[0]);
    my $v1 = &scanPack ($view[1]);
    for my $f (sort keys (%$v0))
      {
        next if (-f "$cwd/.gitpack/git/$f");
        &doUnlink ($v0->{$f}); delete $v0->{$f};
        &doUnlink ($v1->{$f}); delete $v1->{$f};
      }

    # Removed files from parent pack become empty
    my $p = &scanPack (@view[2..$#view]);
    for my $f (sort keys (%$p))
      {
        next if (-f "$cwd/.gitpack/git/$f");
        $f = "$cwd/.gitpack/tmp/$f";
        &doUnlink ($f);
        &doZeroFile ($f);
      }


    for my $f (sort keys (%$v1))
      {
        next if ($v0->{$f});
        &doUnlink ($v1->{$f});
        delete ($v1->{$f});
      }

    for my $f (sort keys (%$v0))
      {
        my $f0 = $v0->{$f};
        my $stf0 = stat ($f0);
        next if (&newer ($s, $f0, $sts, $stf0));
        my $f1 = $v1->{$f};
        goto LINK unless ($f1);
        my $stf1 = stat ($f1);
        next if (&testEqualFiles ($f0, $f1, $stf0, $stf1));
LINK:
        $f1 = "$cwd/$view[1]/$f";
        &doLink ($f0, $f1);
      }

  }

'FileHandle'->new (">$s");



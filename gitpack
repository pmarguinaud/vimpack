#!/usr/bin/perl -w

use strict;
use File::Find;
use File::Path;
use File::Basename;
use FileHandle;
use File::stat;
use Data::Dumper;
use Storable;
use Cwd;
use Getopt::Long;

my @GIT = ('/bin/git');
my $GITPACK = '.gitpack';

sub bt
{ 
  print @_;
  for (my $i = 0; ; $i++)
    {
      last unless (my @call = caller ($i));
      print " $i ", $call[1], ':', $call[2], "\n";
    }
  die "\n";
}

local $SIG{__WARN__} = \&bt;
local $SIG{__DIE__} = \&bt;

sub run
{
  my @cmd = @_;
  system (@cmd) and die ("Command `@cmd' failed\n");
}

my $gitpack_time = "$GITPACK/time";

sub getView
{
  my @view = do { my $fh = 'FileHandle'->new ('<.gmkview'); <$fh> };
  chomp for (@view);
  my $cwd = &cwd ();
  @view = map { "$cwd/src/$_" } @view;
  return @view;
}

sub init
{
  my %opts = @_;
  return if (-d "$GITPACK");

  my $cwd = &cwd ();

  my @view = &getView ();

  if (my $git = $opts{repository})
    {
      my $p = &scanPack (@view[1..$#view]);

      &mkpath ("$GITPACK/git");
      &run ("cp -alf $git/* ./$GITPACK/git/");
      &run ("cp -r $git/.git ./$GITPACK/git/.git");
      
      my $g = &scanPack ("$cwd/$GITPACK/git");

      my @f = sort keys (%{ {%$p, %$g} });

      for my $f (@f)
        {
          my @l = ("$cwd/$GITPACK/tmp/$f", "$view[0]/$f");
          my $stp = $p->{$f} && stat ($p->{$f});
          my $stg = $g->{$f} && stat ($g->{$f});
          if ($p->{$f} && $g->{$f})
            {
              unless (&testEqualFiles ($p->{$f}, $g->{$f}))
                {
                  &doLink ($g->{$f}, $_) for (@l);
                }
            }
          elsif ($p->{$f} && (! $g->{$f}))
            {
              &doZeroFile ($_) for (@l);
            }
          elsif ((! $p->{$f}) && $g->{$f})
            {
              &doLink ($g->{$f}, $_) for (@l);
            }
        }

    }
  elsif (scalar (@view) > 1)
    {
      my $pack = readlink ($view[1]); $pack = &dirname ($pack) for (1 .. 2);

      die unless (-d "$pack/$GITPACK/git");

      &mkpath ("$GITPACK/git");

      &run ("cp -alf $pack/$GITPACK/git/* ./$GITPACK/git/");
      &run ("cp -r $pack/$GITPACK/git/.git ./$GITPACK/git/.git");
    }
  else
    {
      die ("No git repository was found\n");
    }
  
  &mkpath ("$GITPACK/tmp");

  'FileHandle'->new (">$gitpack_time");
}

sub check
{
  my @view = &getView ();

  my $cwd = &cwd ();

  my $p = &scanPack (@view);
  my $g = &scanPack ("$cwd/$GITPACK/git");

  my @f = sort keys (%{ {%$p, %$g} });

  for my $f (@f)
    {
      my $stp = $p->{$f} && stat ($p->{$f});
      my $stg = $g->{$f} && stat ($g->{$f});
      if ($p->{$f} && $g->{$f})
        {
          unless (&testEqualFiles ($p->{$f}, $g->{$f}))
            {
              print "M $f\n";
            }
        }
      elsif ($p->{$f} && (! $g->{$f}))
        {
          print "+ $f\n";
        }
      elsif ((! $p->{$f}) && $g->{$f})
        {
          print "- $f\n";
        }
    }
}


my $cwd = &cwd ();

my %opts;

sub git
{
  use POSIX qw ();
  my %args = @_;
  chdir ("$cwd/$GITPACK/git");

  my @cmd = (@GIT, @{ $args{cmd} || [] });

  print "@cmd\n" if ($opts{verbose});

  my $c = 0;

  if (system (@cmd))
    {
      $c = $?;
      my $signal = $c & 127;
      if ($args{die})
        {
          die unless ($signal == &POSIX::SIGPIPE); # Ignore PIPE signal (generated by "| less")
        }
    }
  chdir ($cwd);

  return ! $c;
}

my @r = qw (branch push status log show commit fetch diff);
my @w = qw (checkout pull merge reset);

sub bash
{
  for my $command (@r, @w)
    {
      print (<< "EOF");
function $command ()
{
  gitpack $command \$*
}

EOF
    }
}

my @opts_f = qw (verbose init bash help check force-r force-w);
my @opts_s = qw (repository);

sub help
{
  print "Usage: " . &basename ($0) . "\n" 
      . " Options:\n" . join ('', map { "   --$_\n" } @opts_f, @opts_s)
      . " Commands:\n" . join ('', map { "   * $_\n" } (@r, @w));
}

my $stgitpack_time = stat ($gitpack_time);

sub resetTime
{
  utime (0, 0, $gitpack_time);
  $stgitpack_time = stat ($gitpack_time);
}

if (@ARGV && ($ARGV[0] =~ m/^-/o))
  {
    &GetOptions
    (
      (map { ($_, \$opts{$_}) } @opts_f),
      (map { ("$_=s", \$opts{$_}) } @opts_s),
    );
    if ($opts{init})
      {
        &init (%opts);
        exit (0);
      }
    elsif ($opts{bash})
      {
        &bash (%opts);
        exit (0);
      }
    elsif ($opts{check})
      {
        &check (%opts);
        exit (0);
      }
    elsif ($opts{help})
      {
        &help (%opts);
        exit (0);
      }
    elsif ($opts{'force-r'})
      {
        &resetTime ();
        &r ();
        exit (0);
      }
    elsif ($opts{'force-w'})
      {
        &resetTime ();
        &w ();
        exit (0);
      }
  }

my $command = shift;
my @args = @ARGV;

$command or exec (@GIT);

my $r = grep { $_ eq $command } @r;
my $w = grep { $_ eq $command } @w;

unless ($r || $w)
  {
    die ("Unknown command `$command'\n");
  }


sub scanPack
{
  my @view = @_;

  my $key = join (',', @view); $key =~ s,/,+,go;
  my $file = "$GITPACK/scan/scan.$key.pl";

  my $p = {};

  if (-f $file)
    {
      $p = &Storable::retrieve ($file);
    }
  else
    {
      my $cwd = &cwd ();
      for my $view (@view)
        {
          chdir ($view);
          my $wanted = sub 
          { 
            my $f = $File::Find::name; 
            $p->{$f} ||= 'File::Spec'->rel2abs ($f) if (&ok ($f)) 
          };
          if (my @dir = grep { -d } <*>)
            {
              &find ({wanted => $wanted, no_chdir => 1}, @dir); 
            }
          chdir ($cwd);
        }
     
      if (@view && (-l $view[0]))
        {
          # Cache the result
          &mkpath ("$GITPACK/scan");
          &Storable::nstore ($p, $file);
        }
    }

  return $p;
}

sub ok
{
  my $f = shift;
  return unless (-f $f);
  return if ($f =~ m/\.(?:lst|optrpt|o|mod|ok|swp)$/o);
  return if ($f =~ m,odb/ddl\.\w+/\w+.(?:c|h|ddl_),o);
  return 1;
}

sub doLink
{
  my ($f, $g) = @_;
  print "LN $f $g\n" if ($opts{verbose});
  unlink ($g) if (-f $g);
  my $d = &dirname ($g);
  &mkpath ($d) unless (-d $d);
  link ($f, $g);
}

sub doZeroFile
{
  my $f = shift;
  my $d = &dirname ($f);
  &mkpath ($d) unless (-d $d);
  unlink ($f);
  print "ZERO $f\n" if ($opts{verbose});
  'FileHandle'->new (">$f");
}

sub doUnlink
{
  my $f = shift;
  print "RM $f\n" if ($opts{verbose});
  unlink ($f);
}

sub slurp
{
  my $f = shift;
  my $fh = 'FileHandle'->new ("<$f");
  local $/ = undef;
  my $data = <$fh>;
  return $data;
}

sub testEqualFiles
{
  # Try to make it fast
  my ($f, $g, $stf, $stg) = @_;

  $stf ||= stat ($f);
  $stg ||= stat ($g);

  # Very same file
  return 1 if (($stf->dev == $stg->dev) && ($stf->ino == $stg->ino));

  # Different size 
  return 0 if ($stf->size != $stg->size);

  # Slow: compare file contents
  return 1 if (&slurp ($f) eq &slurp ($g));

  return 0;
}

sub newer
{
  my ($f, $g, $stf, $stg) = @_;
  return $stf->mtime > $stg->mtime;
}


sub r
{
  my @view = &getView ();
  unshift (@view, "$cwd/$GITPACK/tmp");

  # Compare tmp and local and see what has changed

  my $v0 = &scanPack ($view[0]); # Scan tmp
  my $v1 = &scanPack ($view[1]); # Scan local
  
  my @f = keys (%{ {%$v0, %$v1} });
  
  my (@p, @m, @c, @z); # +, -, changed, zero
  
  for my $f (@f)
    {
      my ($f0, $f1) = ($v0->{$f}, $v1->{$f});
  
      my $stf0 = $f0 && stat ($f0);
      my $stf1 = $f1 && stat ($f1);
  
      if ($f1)
        {
          next if (&newer ($gitpack_time, $f1, $stgitpack_time, $stf1));
          # Newly zeroed file
          if (($stf1->size == 0) && ((! $stf0) || ($stf0->size)))
            {
              my $exists = 0;
              # Check it does exist in parent pack
              for my $view (@view[2,$#view])
                {
                  last if ($exists = -f "$view/$f");
                }
              if ($exists)
                {
                  push @z, $f;
                  next; 
                }
            }
        }
  
      if ($f0 && (! $f1))
        {
          push @m, $f;
        }
      elsif ($f1 && (! $f0))
        {
          push @p, $f;
        }
      elsif (! &testEqualFiles ($f0, $f1, $stf0, $stf1))
        {
          push @c, $f;
        }
    }
  
  # Add new/modified files
  
  for my $f (@c, @p)
    {
      &doLink ($v1->{$f}, "$cwd/$GITPACK/tmp/$f");
      &doLink ($v1->{$f}, "$cwd/$GITPACK/git/$f"); 
      &git (cmd => ['add', '-f', $f], die => 1);
    }
  
  # Remove deleted files
  
  for my $f (@m)
    {
      &doUnlink ("$cwd/$GITPACK/tmp/$f");
      &git (cmd => ['rm', '-f', '--quiet', $f], die => 1);
    }
  
  for my $f (@z)
    {
      &doLink ($v1->{$f}, "$cwd/$GITPACK/tmp/$f");
      &git (cmd => ['rm', '-f', '--quiet', $f], die => 1);
    }
}

sub w
{
  my @view = &getView ();
  unshift (@view, "$cwd/$GITPACK/tmp");

  my $g = &scanPack ("$GITPACK/git");

  # Add new files from repository to tmp and local

  MAIN: for my $f (sort keys (%$g))
    {
      my $stf = stat ($g->{$f});
   
      # This file has already been looked at earlier; skip it
      next MAIN if (&newer ($gitpack_time, $g->{$f}, $stgitpack_time, $stf));
     
      if (my $stl = stat ("$view[0]/$f"))
        {
          unless ($stl->size) 
            {
              # File was marked as removed in tmp directory, but was retrieved by a checkout
              # Remove the zero sized file
              &doUnlink ("$view[$_]/$f") for (0 .. 1);
            }
        }

      for my $view (@view[2..$#view])
        {
          my $v = "$view/$f";
          next unless (my $stv = stat ($v));
          if (&testEqualFiles ($g->{$f}, $v, $stf, $stv))
            {
              # File exists and is the same as in the git repo, remove local copy
              &doUnlink ("$view[$_]/$f") for (0 .. 1);
              next MAIN;
            }
          else
            {
              last;
            }
         }
      &doLink ($g->{$f}, "$view[$_]/$f") for (0 .. 1);
    }

  # Remove files from tmp and local, when they have vanished from repository

  my $v0 = &scanPack ($view[0]);
  my $v1 = &scanPack ($view[1]);
  for my $f (sort keys (%$v0))
    {
      next if (-f "$cwd/$GITPACK/git/$f");
      &doUnlink ($v0->{$f}); delete $v0->{$f};
      &doUnlink ($v1->{$f}); delete $v1->{$f};
    }

  # Removed files from parent pack become empty
  my $p = &scanPack (@view[2..$#view]);
  for my $f (sort keys (%$p))
    {
      next if (-f "$cwd/$GITPACK/git/$f");
      for my $view (@view[0,1])
        {
          my $g = "$view/$f";
          &doZeroFile ($g); 
        }
    }

}


#####        First part : update git repository with local changes         #####

&r ();

#####                   Second part : run git command                      #####

my $c = &git (cmd => [$command, @args], die => 0);

#####          Third part : update local and tmp using repository          #####

&w () if ($w);

'FileHandle'->new (">$gitpack_time");

exit ($c);



#!/usr/bin/perl -w

use strict;
use File::Find;
use File::Path;
use File::Basename;
use FileHandle;
use File::stat;
use Data::Dumper;
use Storable;
use Cwd;
use Getopt::Long;

my @GIT = ('/bin/git');
my $GITPACK = '.gitpack';

sub bt
{ 
  print @_;
  for (my $i = 0; ; $i++)
    {
      last unless (my @call = caller ($i));
      print " $i ", $call[1], ':', $call[2], "\n";
    }
  die "\n";
}

local $SIG{__WARN__} = \&bt;
local $SIG{__DIE__} = \&bt;

sub run
{
  my @cmd = @_;
  system (@cmd) and die ("Command `@cmd' failed\n");
}

my $gitpack_time = "$GITPACK/time";

sub init
{
  return if (-d "$GITPACK");
  my @view = do { my $fh = 'FileHandle'->new ('<.gmkview'); <$fh> };
  chomp for (@view);

  my $pack = readlink ("src/$view[1]"); $pack = &dirname ($pack) for (1 .. 2);

  die unless (-d "$pack/$GITPACK/git");

  &mkpath ("$GITPACK/git");

  &run ("cp -alf $pack/$GITPACK/git/* ./$GITPACK/git/");
  &run ("cp -r $pack/$GITPACK/git/.git ./$GITPACK/git/.git");
  
  'FileHandle'->new (">$gitpack_time");
}

my $cwd = &cwd ();

my %opts;

sub git
{
  use POSIX qw ();
  my ($command, @args) = @_;
  chdir ("$cwd/$GITPACK/git");

  my @cmd = (@GIT, $command, @args);
  print "@cmd\n" if ($opts{verbose});

  if (system (@cmd))
    {
      my $c = $?;
      my $signal = $c & 127;
      die unless ($signal == &POSIX::SIGPIPE); # Ignore PIPE signal (generated by "| less")
    }
  chdir ($cwd);
}

my @r = qw (branch push status log show commit fetch diff);
my @w = qw (checkout pull merge reset);

sub bash
{
  for my $command (@r, @w)
    {
      print (<< "EOF");
function $command ()
{
  gitpack $command \$*
}

EOF
    }
}

my @opts_f = qw (verbose init bash help);

sub help
{
  print "Usage: " . &basename ($0) . "\n" 
      . " Options:\n" . join ('', map { "   --$_\n" } @opts_f)
      . " Commands:\n" . join ('', map { "   * $_\n" } (@r, @w));
}

if (@ARGV && ($ARGV[0] =~ m/^-/o))
  {
    &GetOptions
    (
      (map { ($_, \$opts{$_}) } @opts_f),
    );
    if ($opts{init})
      {
        &init ();
        exit (0);
      }
    elsif ($opts{bash})
      {
        &bash ();
        exit (0);
      }
    elsif ($opts{help})
      {
        &help ();
        exit (0);
      }
  }

my $command = shift;
my @args = @ARGV;

my @view = do { my $fh = 'FileHandle'->new ('<.gmkview'); <$fh> };
chomp for (@view);
@view = map { "src/$_" } @view;
@view = ("$GITPACK/tmp", @view);

$command or exec (@GIT);

my $r = grep { $_ eq $command } @r;
my $w = grep { $_ eq $command } @w;

unless ($r || $w)
  {
    die ("Unknown command `$command'\n");
  }


sub scanPack
{
  my @view = @_;

  my $key = join (',', @view); $key =~ s,/,+,go;
  my $file = "$GITPACK/scan/scan.$key.pl";

  my $p = {};

  if (-f $file)
    {
      $p = &Storable::retrieve ($file);
    }
  else
    {
      for my $view (@view)
        {
          chdir ("$cwd/$view");
          my $wanted = sub 
          { 
            my $f = $File::Find::name; 
            $p->{$f} ||= 'File::Spec'->rel2abs ($f) if (&ok ($f)) 
          };
          &find ({wanted => $wanted, no_chdir => 1}, grep { -d } <*>);
          chdir ($cwd);
        }
     
      if (@view && (-l $view[0]))
        {
          # Cache the result
          &mkpath ("$GITPACK/scan");
          &Storable::nstore ($p, $file);
        }
    }

  return $p;
}

sub ok
{
  my $f = shift;
  return unless (-f $f);
  return if ($f =~ m/\.(?:lst|optrpt|o|mod|ok)$/o);
  return if ($f =~ m,odb/ddl\.\w+/\w+.(?:c|h|ddl_),o);
  return 1;
}

sub doLink
{
  my ($f, $g) = @_;
  print "LN $f $g\n" if ($opts{verbose});
  unlink ($g) if (-f $g);
  my $d = &dirname ($g);
  &mkpath ($d) unless (-d $d);
  link ($f, $g);
}

sub doZeroFile
{
  my $f = shift;
  my $d = &dirname ($f);
  &mkpath ($d) unless (-d $d);
  unlink ($f);
  print "ZERO $f\n" if ($opts{verbose});
  'FileHandle'->new (">$f");
}

sub doUnlink
{
  my $f = shift;
  print "RM $f\n" if ($opts{verbose});
  unlink ($f);
}

sub slurp
{
  my $f = shift;
  my $fh = 'FileHandle'->new ("<$f");
  local $/ = undef;
  my $data = <$fh>;
  return $data;
}

sub testEqualFiles
{
  # Try to make it fast
  my ($f, $g, $stf, $stg) = @_;

  $stf ||= stat ($f);
  $stg ||= stat ($g);

  # Very same file
  return 1 if (($stf->dev == $stg->dev) && ($stf->ino == $stg->ino));

  # Different size 
  return 0 if ($stf->size != $stg->size);

  # Slow: compare file contents
  return 1 if (&slurp ($f) eq &slurp ($g));

  return 0;
}

sub newer
{
  my ($f, $g, $stf, $stg) = @_;
  return $stf->mtime > $stg->mtime;
}

my $stgitpack_time = stat ($gitpack_time);


#####        First part : update git repository with local changes         #####

# Compare tmp and local and see what has changed

my $v0 = &scanPack ($view[0]); # Scan tmp
my $v1 = &scanPack ($view[1]); # Scan local

my @f = keys (%{ {%$v0, %$v1} });

my (@p, @m, @c, @z); # +, -, changed, zero

for my $f (@f)
  {
    my ($f0, $f1) = ($v0->{$f}, $v1->{$f});

    my $stf0 = $f0 && stat ($f0);
    my $stf1 = $f1 && stat ($f1);

    if ($f1)
      {
        next if (&newer ($gitpack_time, $f1, $stgitpack_time, $stf1));
        # Newly zeroed file
        if (($stf1->size == 0) && ((! $stf0) || ($stf0->size)))
          {
            my $exists = 0;
            # Check it does exist in parent pack
            for my $view (@view[2,$#view])
              {
                last if ($exists = -f "$cwd/$view/$f");
              }
            if ($exists)
              {
                push @z, $f;
                next; 
              }
          }
      }

    if ($f0 && (! $f1))
      {
        push @m, $f;
      }
    elsif ($f1 && (! $f0))
      {
        push @p, $f;
      }
    elsif (! &testEqualFiles ($f0, $f1, $stf0, $stf1))
      {
        push @c, $f;
      }
  }

#print &Dumper ([p => \@p, m => \@m, c => \@c, z => \@z]);

# Add new/modified files

for my $f (@c, @p)
  {
    &doLink ($v1->{$f}, "$cwd/$GITPACK/tmp/$f");
    &doLink ($v1->{$f}, "$cwd/$GITPACK/git/$f"); 
    &git ('add', '-f', $f);
  }

# Remove deleted files

for my $f (@m)
  {
    &doUnlink ("$cwd/$GITPACK/tmp/$f");
    &git ('rm', '-f', '--quiet', $f);
  }

for my $f (@z)
  {
    &doLink ($v1->{$f}, "$cwd/$GITPACK/tmp/$f");
    &git ('rm', '-f', '--quiet', $f);
  }

#####                   Second part : run git command                      #####

&git ($command, @args);

#####          Third part : update local and tmp using repository          #####

if ($w)
  {
    my $g = &scanPack ("$GITPACK/git");

    # Add new files from repository to tmp and local

    MAIN: for my $f (sort keys (%$g))
      {
        my $stf = stat ($g->{$f});
     
        # This file has already been looked at earlier; skip it
        next MAIN if (&newer ($gitpack_time, $g->{$f}, $stgitpack_time, $stf));
       
        if (my $stl = stat ("$cwd/$view[0]/$f"))
          {
            unless ($stl->size) 
              {
                # File was marked as removed in tmp directory, but was retrieved by a checkout
                # Remove the zero sized file
                &doUnlink ("$cwd/$view[$_]/$f") for (0 .. 1);
              }
          }

        for my $view (@view[2..$#view])
          {
            my $v = "$cwd/$view/$f";
            next unless (my $stv = stat ($v));
            if (&testEqualFiles ($g->{$f}, $v, $stf, $stv))
              {
                # File exists and is the same as in the git repo, remove local copy
                &doUnlink ("$cwd/$view[$_]/$f") for (0 .. 1);
                next MAIN;
              }
            else
              {
                last;
              }
           }
        &doLink ($g->{$f}, "$cwd/$view[$_]/$f") for (0 .. 1);
      }

    # Remove files from tmp and local, when they have vanished from repository

    my $v0 = &scanPack ($view[0]);
    my $v1 = &scanPack ($view[1]);
    for my $f (sort keys (%$v0))
      {
        next if (-f "$cwd/$GITPACK/git/$f");
        &doUnlink ($v0->{$f}); delete $v0->{$f};
        &doUnlink ($v1->{$f}); delete $v1->{$f};
      }

    # Removed files from parent pack become empty
    my $p = &scanPack (@view[2..$#view]);
    for my $f (sort keys (%$p))
      {
        next if (-f "$cwd/$GITPACK/git/$f");
        for my $view (@view[0,1])
          {
            my $g = "$cwd/$view/$f";
            &doZeroFile ($g); 
          }
      }

  }

'FileHandle'->new (">$gitpack_time");



#!/usr/bin/perl -w

=head1 NAME

synpack

=head1 SYNOPSIS

  # Modify the code
  [ECA 49t1_test1.03.IMPIIFC2018.x]$ vimpack stepo.F90                                
  # Merge modifications in another pack
  [ECA 49t1_test1.03.IMPIIFC2018.x]$ synpack --pack1 ../49t1_test2.03.IMPIIFC2018.x     

=head1 DESCRIPTION

Report modifications from one pack into another, using C<gitpack>.

=head1 PRINCIPLES

When invoked, C<synpack> will do the following:

=over 4

=item 1

Attempt to compile the code in the current pack, if C<MASTERODB> is not up-to-date.

=item 2

Commit the last changes with the message passed with the C<--message> option.

=item 3

Try to merge the current branch into the pack passed with C<--pack1> option.

=item 4

Try to compile C<MASTERODB> in the passed with C<--pack1> option.

=back

If step 3 or 4 fails, an interactive shell will be created and the user will be expected to :

=over 4

=item

If step 3 has failed, finish the merge by hand and commit the last modifications in pack1.

=item

If step 4 has failed, fix the code and commit the last modifications in pack1.

=back

=head1 SEE ALSO

C<gmkpack>, C<gitpack>, C<vimpack>

=head1 AUTHOR

pmarguinaud@hotmail.com

=cut

use strict;
use FileHandle;
use Cwd;
use File::stat;
use File::Find;
use File::Spec;
use File::Copy;
use File::Path;
use File::Basename;
use Getopt::Long;
use Data::Dumper;
use Term::ANSIColor;
use FindBin qw ($Bin);

use lib "$Bin/lib";

use bt;


sub runCommand
{
  my %args = @_; 
  my @cmd = @{ ${args}{command} };

  my $cwd = &cwd ();

  if ($args{chdir})
    {
      chdir ($args{chdir}) or die ("Cannot chdir $args{chdir}\n");
    }

  print "@cmd\n" if ($args{verbose});

  my $c = system (@cmd);

  if ($c && (my $eh = $args{errorHandler}))
    {
      $c = $eh->(@cmd);
    }

  chdir ($cwd);

  $c and die ("Command `@cmd' failed\n");
}

sub runGitPackCommand
{
  my %args = @_; 

  my ($pack, $cwd) = ($args{pack}, &cwd ());

  $pack && chdir ($pack);

  my @cmd = @{ ${args}{command} };

  print "cwd=" . &cwd () . "\n@cmd\n" if ($args{verbose});

  my $out = `@cmd`;
  my $c = $?;

  if ($c && (my $eh = $args{errorHandler}))
    {
      $c = $eh->(@cmd);
    }

  chdir ($cwd);

  die ("Gitpack command `@cmd' failed\n")
    if ($c);

  return $out;
}

sub needReBuild
{
  my %args = @_;

  my $pack = $args{pack} || &cwd ();

  my $MASTERODB = "$pack/bin/MASTERODB";

  return 1 unless (-f $MASTERODB);

  my $t0 = stat ("$pack/bin/MASTERODB")->mtime ();

  my $rebuild = 0;

  &find ({wanted => sub 
  {  
    my $f = $File::Find::name;
    return unless ((-f $f) && ($f =~ m/\.F90$/o));
    my $st = stat ($f);
    $rebuild ||= $st->mtime () > $t0;
  }, no_chdir => 1}, "$pack/src/local/");

  return $rebuild;
}

sub slurp
{
  my $f = shift;
  (my $fh = 'FileHandle'->new ("<$f")) or die ("Cannot open `$f'\n");
  local $/ = undef;
  my $data = <$fh>;
  return $data;
}

sub filesEqual
{
  my ($f0, $f1) = @_;
  return &slurp ($f0) eq &slurp ($f1);
}


sub getBranch
{
  chomp (my $branch = &runGitPackCommand (@_, command => [qw (gitpack rev-parse --abbrev-ref HEAD)]));
  return $branch;
}

sub getStatus
{
  my $status = &runGitPackCommand (@_, command => [qw (gitpack status --porcelain)]);
  return $status;
}

sub getCommit
{
  chomp (my $commit = &runGitPackCommand (@_, command => [qw (gitpack rev-parse HEAD)]));
  return $commit;
}

sub rebuildIfNeeded
{
  my %args = @_;
  my $pack = $args{pack} || &cwd ();

  &runCommand (%args, command => ['./ics_masterodb'], chdir => $pack)
    if (&needReBuild (pack => $pack));
}

my %opts = (qw (verbose 0 message Commit), pack0 => &cwd ());

my @opts_f = qw (up verbose help);
my @opts_s = qw (message pack0 pack1);

sub help
{
  print "Usage: " . &basename ($0) . "\n" 
      . " Options:\n" . join ('', map { "   --$_\n" } @opts_f, @opts_s);
}

sub getView
{
  my %args = @_;

  $args{local} = 1 unless (exists $args{local});

  my $pack = $args{pack};

  my @view = do { my $fh = 'FileHandle'->new ("<$pack/.gmkview"); <$fh> };
  chomp for (@view);

  my @pack = (shift (@view) => $pack);

  unless ($args{local})
    {
      @pack = ();
    }

  for my $view (@view)
    {
      (my $link = readlink ("src/$view")) or die;
      push @pack, $view, &dirname (&dirname ($link));
    }

  return @pack;
}

if (-f '.synpack.conf')
  {
    unshift (@ARGV, @{ do ("./.synpack.conf") || [] });
  }

&GetOptions
(
  (map { ($_, \$opts{$_}) } @opts_f),
  (map { ("$_=s", \$opts{$_}) } @opts_s),
);

if ($opts{help})
  {
    print "Usage: " . &basename ($0) . "\n" 
        . " Options:\n" . join ('', map { "   --$_\n" } @opts_f, @opts_s);
    exit (0);
  }

my $pack0 = 'File::Spec'->rel2abs ($opts{pack0});

my @view = &getView (pack => $pack0, local => 0);

if ($opts{'up'})
  {
    $opts{pack1} = scalar (@view) ? $view[1] : undef;
  }

my $pack1 = 'File::Spec'->rel2abs ($opts{pack1});

$opts{'up'} = scalar (@view) > 0 && ($view[1] eq $pack1) ? $view[0] : undef;

for my $opt (qw (pack0 pack1))
  {
    die unless ($opts{$opt});
    die unless (-f "$opts{$opt}/.genesis");
  }


sub PP
{

  print "\n" x 4;
  print "@_\n" x 4;
  print "\n" x 4;

}


&PP ("REBUILD $pack0");

&rebuildIfNeeded (%opts, pack => $pack0);

if (&getStatus (%opts, pack => $pack0))
  {
    &PP ("COMMIT IN $pack0");
    &runGitPackCommand (%opts, pack => $pack0, command => [qw (gitpack commit -a), -m => $opts{message}]);
  }

my $branch0 = &getBranch (pack => $pack0);

my $BASHRC = << 'EOF';

if [ -f ~/.bashrc ]
then
  . ~/.bashrc
fi

if [ -f ~/.bash_profile ]
then
  . ~/.bash_profile
fi

pwd

EOF

&PP ("MERGE IN $pack1");

&runGitPackCommand 
  (%opts, pack => $pack1, command => [qw (gitpack pull), "$pack0/.gitpack/git", $branch0], errorHandler => sub
{
  my @cmd = @_;

  my $MERGE = &colored ('[MERGE]', 'black on_cyan');

  'FileHandle'->new ('>.synpack.sh')->print (<< "EOF");

$BASHRC

export PS1="$MERGE-$ENV{PS1}"

gitpack status

EOF

  chmod (0755, 'cmd.sh');
  system (qw (bash --init-file ./.synpack.sh -i));

  return 0;
});


&PP ("REBUILD $pack1");

&rebuildIfNeeded (%opts, pack => $pack1, errorHandler => sub
{
  my @cmd = @_;

  my $BUILD = &colored ('[BUILD]', 'black on_cyan');

  'FileHandle'->new ('>.synpack.sh')->print (<< "EOF");

$BASHRC

export PS1="$BUILD-$ENV{PS1}"

EOF

  chmod (0755, 'cmd.sh');
  system (qw (bash --init-file ./.synpack.sh -i));

  return 0;
});


&PP ("UP");


if (my $view1 = $opts{up})
  {
    &runCommand (command => ['cleanpack', '-f'], chdir => $pack0);
    &runCommand (command => ['resetpack', '-f'], chdir => $pack0);
    &runCommand (command => ['./ics_masterodb'], chdir => $pack0);

    my $text = &slurp ("$pack1/src/.gmak/local.sds");
    $text =~ s/'local'/'$view1'/gms;
    'FileHandle'->new (">$pack0/src/.gmak/$view1.sds")->print ($text);

    &runGitPackCommand (%opts, pack => $pack0, command => [qw (gitpack checkout -f -q), $branch0]);

    &rmtree ("$pack0/.vimpack");
    &runCommand (command => ['vimpack', '-i'], chdir => $pack0);

  }
